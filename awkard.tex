\documentclass[a4paper,12pt]{article}
\usepackage{amsfonts}
\begin{document}

\title{Awkward State Machines}
\author{Will Dengler}
\maketitle

\section{Introduction}
Imagine you had a ball of yarn of infinite length and a pair of scizzors. Now choose some arbitrary length of yarn and cut it - we'll refer to this length as 1. Next, cut a second strand of yarn that has length 2 relative to your original piece of yarn and set it aside. Now, extend the yarn to length 3 and repeat the following instructions:
\begin{enumerate}
\item For every strand of yarn you have cut so far (other than the strand of length 1), check if the current extension of yarn can be split into even segments of the same length as the current strand by 'walking' the shorter strand up the longer one until you reach the end of or pass the end of the extended piece of yarn; if you reach the end of the extended piece exactly, then the extension can be divided into even segments. If none of the previous strands can be used to divide the current extension evenly, then double the length of the extended peice of yarn, then cut it in half, finally, set the cut strand aside with the others. Do not cut the extension if one of the previous strands does divide the extension evenly.
\item Using your strand of length 1, increase the length of the extension by 1.
\item Repeat the above two steps.
\end{enumerate} 

If you follow the above instructions, then order the strands of yarn you cut by their length, and finally wrote out their lengths relative to the strand of length 1, then you will find yourself writing down the prime numbers in consequetive order. The fact that this simple experiment derives the prime numbers using relative distance has always fascinated me. I've always had an itching notion that an algorithm based solely on relative distance, rather than integer arithmetic, would outperform the standard methods for discovering the primes in consequetive order. However, the problem of how to encode distance and divisibility without actually using numbers seemed to be impossible; after all, how do you tell a computer to use a ball of yarn and scizzors? And even if we could, the act of walking the strands up the extension is going to be pretty slow. 

Let's modify our experiment slightly to include tacks and a corkboard. Start again by cutting some length of yarn for defining length 1. Now, using your piece of yarn, seperate two tacks on your board 1 unit away from one another. You can now determine the strand of length two by wrapping your ball of yarn around the tacks such that you start at one tack, wrap around the second, and then return to the first tack, then cut the yarn to produce the strand of length two. Now use the strand of length two to place two more tacks in your board at 2 units apart.Now using the tacks for length 1, create a strand of length 3 and repeat the following instructions:   
\begin{enumerate}
\item For every pair of tacks on the board (other than the unit tacks), wrap the current extension of yarn around the tacks to check for divisibility. The extension is divisible if the yarn perfectly touches one of the tacks when it runs out of length. If none of the current pairs of tacks divide the extension evenly, then double the extension, cut it in half, and use the new strand to set apart a new pair of tacks on your board.
\item Use the unit pair of tacks to increase the length of the extension by 1.
\item Repeat the above two steps.
\end{enumerate} 

The above experiment is very simliar to the first. The pairs of tacks you've placed will wind up enumerating the primes once again. We are also still stuck with the problem of how could we encode this algorithm without integers, and the algorithm still isn't performing very quickly. However, the algorithm does highlight an important concept, our tacks use circles (technically ovals) in order to check the length of the extended piece of yarn. This is amazing because it allows us to check for divisiblity without counting anything out, instead, we just keep wrapping the yarn around until we get to the end; thus we don't need to know \textit{how} many times we've wrapped the yarn around, we just have to look where it winds up at the end.   

Let's modify our experiment once again. This time, you need tacks, a corkboard, and little flags that you can stick into the board (a needle with red tape for example). Start by placing two tacks down on the leftmost side of the board in a vertical line, and place a flag next to the bottom tack. Next, place three tacks in a vertical line to the right of those (imagine you are creating a bar graph with the tacks) and place a flag next to the highest tack. This expirement will require you to keep the vertical lines you create with the tacks distinct from one another, we shall refer to each line as a bar. Each bar in your board will always have a flag next to one of it's tacks. Repeat the following to run the experiment:
\begin{enumerate}
\item For every bar except the rightmost, move the flag to the tack above the one it is currently at; unless the flag is currently at the topmost tack in the bar, then move the flag to the bottom tack in the bar.
\item If there are no flags on any of the bottom tacks after you've moved every bar (other than the rightmost), then move the flag of the rightmost bar to its bottom tack and then create a new bar to the right of it that has one more tack than it, and place the new bar's flag at it's top tack.  
\item If there was a flag on one of the bottom tacks, then add a new tack to the top of the rightmost bar, and place it's flag next to the new tack.
\item Repeat the above three steps. 
\end{enumerate}

If you run the above experiment and then count the number of tacks in each bar, you will find that the number of tacks in the bars enumerate the prime numbers in consequetive order. How did this happen? Well, this experiment is much more similar to the last two than it first appears. In this case, the way we move the flags on each bar is the same as wrapping the extended piece of yarn around the tacks in experiment two, or 'walking' the yarn up the extended piece of yarn from experiment one. However, this time our flags our able to preserve the state from the last iteration since you just have to move the flags one tack forward. The moving of each tack can be done in constant time for each bar, and is incredibly fast relative to the time it takes to re-wrap the extended strand of yarn around the tacks, or perform the 'walks'. Furthermore, this expirement doesn't need distance; rather, it only needs relative position (bottom tack, tack above that, ..., tack below top tack, top tack). By replacing distance with relative position, we can easily encode our experiment without the use of numbers using cycle graphs implemented via linked lists. 
  
\section{The Prime Graph Machine}


\section{Activation Cycle Machines}


\textbf{Definition} \\
An activation cycle machine (ACM) is a directed cycle graph, $C$, containing $0 < n < |G|$ consequetive nodes called activation nodes.

We can refer to the $ACM$ containing, $a$, activation nodes and, $n$, non-activation nodes as $C_{a,n}$.
 
An $ACM$'s length is equal to the number of nodes it contains; thus, $C_{a,n}$'s length is $a + n$. We use the notation $|C|$ to refer to $C$'s length. 

The activation node that is connected to by a non-activation node is said to be at position $0$, with all other nodes' positions being determined by their relative position to $0$. Thus, there are $|C|$ unique positions the ASM $C$ can have. We use the notation $\overline{C}$ to refer to $C$'s position. Furthermore, we can identify the $|C|$ unique states as $C(0)$, $C(1)$, ..., $C(|C| - 1)$.

An ACM's initial state starts at position $0$, then moves to the next consequetive position with each iteration. We can keep track of how which state we are on using the notation $C^i$, where $i$ refers to how many iterations we've performed. Thus, $C^0$ denotes the initial state, $C^1$ the next, and $C^{50}$ would be the 51st state. We call $i$ the step of the ASM.

An $ACM$'s state is said to be active if it's position is on one of it's activator nodes; otherwise, the $ACM$ is called inactive.\\
\\
\textbf{Definition} \\
For an ASM, $C$, we can define the $*$ operation between two states $C(i)$ and $C(j)$ as:
$C(i) * C(j) =$ $C(i + j$ $mod$ $|C|)$\\
\\
\textbf{Lemma}\\
The $*$ operation for an ASM, $C$, forms a group with $C(0)$ as the identity. We can refer to this group as $<C>$.\\ 
\\
\textit{Proof}\\  
TODO\\
\\
\textbf{Lemma}\\
The group $<C>$ is isomorphic to the group of integers modulo $|C|$.\\
\\
\textit{Proof}\\  
TODO\\
\\
\textbf{Lemma}\\
If $C_{a,n}$ is on position $p$ at step $m$, then $m$ $mod$ $|C| = p$.\\
\\
\textit{Proof}\\  
TODO\\
\\
\textbf{Corollary}\\
$ACM_{a,n}$ is active on step $m$ if and only if $m$ $mod$ $(a + n) < n$\\
\\
  
\section{Awkward State Machines}

\end{document}